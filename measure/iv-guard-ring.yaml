# Contains a set of instructions for a single chip IV measurement on Keithley SMU 2636 (Innopoli)

instruments:
  temperature_resource: "PT100MK1-1DCBA1.temperature"
  pyvisa:
    resource: "GPIB0::1::INSTR"
    name: "Keithley SMU 2636 (Innopoli)"
    invert_voltage: true
    kwargs:
      timeout: 10000


measure:
  - command: "smub.trigger.initiate()"
    type: "write"
  - command: "smua.trigger.initiate()"
    type: "write"
  - command: "waitcomplete()"
    type: "write"
  - command: "smua.source.output = smua.OUTPUT_OFF"
    type: "write"
  - command: "smub.source.output = smub.OUTPUT_OFF"
    type: "write"
  - command: "printbuffer(1, smua.nvbuffer1.n, smua.nvbuffer1.readings)"
    type: "query_csv_values"
    name: anode_current
  - command: "printbuffer(1, smua.nvbuffer1.n, smua.nvbuffer1.sourcevalues)"
    type: "query_csv_values"
    name: voltage_input
  - command: "printbuffer(1, smub.nvbuffer2.n, smub.nvbuffer2.readings)"
    type: "query_csv_values"
    name: guard_current

chips:
  - voltage_input: voltage_input
    anode_current: anode_current
    guard_current: guard_current


measurements:
  - name: 0.01v
    instrument:
      - "reset()" # resets commands to their default settings
      - "smua.source.func = smua.OUTPUT_DCVOLTS" # selects the voltage source function
      - "smua.source.autorangev = smua.AUTORANGE_ON" # enables voltage source autorange
      - "smua.source.limiti = 10e-3" # comlience limit
      - "smua.source.output = smua.OUTPUT_ON" # turn on the output in preparation for the sweep

      - "smua.measure.nplc = 1" # sets the integration time. 0.01 - fast, 0.1 - med, 1 - normal
      - "smua.measure.autozero = smua.AUTOZERO_OFF" # disables automatic updates to the internal reference measurements of the instrument
      - "smua.measure.lowrangei=1e-9" # sets the lowest measurement range that is used when the instruments is autoranging

      - "smub.source.func = smub.OUTPUT_DCVOLTS" # selects the voltage source function
      - "smub.source.output = smub.OUTPUT_ON"
      - "smub.measure.nplc = 1" # sets the integration time. 0.01 - fast, 0.1 - med, 1 - normal
      - "smub.measure.autozero = smub.AUTOZERO_OFF" # disables automatic updates to the internal reference measurements of the instrument
      - "smub.measure.lowrangei=1e-9" # sets the lowest measurement range that is used when the instruments is autoranging

      - "vlist = {0.01,0,-0.01}" # sets the voltage list
      - "points = 3" # counts the point

      # Set the sweep timer
      - "trigger.timer[1].reset()"
      - "trigger.timer[1].delay = 200e-3"
      - "trigger.timer[1].stimulus = smua.trigger.SOURCE_COMPLETE_EVENT_ID" # smu A completes a source action

      # SMU A Buffer
      - "smua.nvbuffer1.clear()" # clear the buffer
      - "smua.nvbuffer1.appendmode = 1" # saves measurement to buffer
      - "smua.nvbuffer1.collectsourcevalues = 1 " # source values are stored with readings in the buffer

      - "smua.trigger.source.listv(vlist)" # sweeps  smuA through vlist
      - "smua.trigger.source.action = smua.ENABLE" # enables the source action
      - "smua.trigger.endpulse.action = smua.SOURCE_HOLD"
      - "smua.trigger.measure.i(smua.nvbuffer1)" # stores current readings during the sweep in buffer
      - "smua.trigger.measure.action = smua.ENABLE" # makes measurement during the sweep
      - "smua.trigger.measure.stimulus = trigger.timer[1].EVENT_ID" # identifies events generated by the timer
      - "smua.trigger.count = points" # number of points to output

       # SMU B Buffer
      - "smub.nvbuffer2.clear()" # clear the buffer
      - "smub.nvbuffer2.appendmode = 1" # saves measurement to buffer

      - "smub.trigger.source.listv({0,0,0})" # sweeps  smub through vlist
      - "smub.trigger.source.action = smub.ENABLE" # enables the source action
      - "smub.trigger.endpulse.action = smub.SOURCE_HOLD"
      - "smub.trigger.measure.i(smub.nvbuffer2)" # stores current readings during the sweep in buffer
      - "smub.trigger.measure.action = smub.ENABLE" # makes measurement during the sweep
      - "smub.trigger.measure.stimulus = trigger.timer[1].EVENT_ID" # identifies events generated by the timer
      - "smub.trigger.count = points" # number of points to output

    program:
      measurements_kwargs:
        int_time: LONG # depends on smua.measure.nplc value. 0.01 - fast (SHORT), 0.1 - med (MED), 1 - normal (LONG)

  - name: 20v
    instrument:
      - "reset()" # resets commands to their default settings
      - "smua.source.func = smua.OUTPUT_DCVOLTS" # selects the voltage source function
      - "smua.source.autorangev = smua.AUTORANGE_ON" # enables voltage source autorange
      - "smua.source.output = smua.OUTPUT_ON" # turn on the output in preparation for the sweep

      - "smua.measure.nplc = 1" # sets the integration time. 0.01 - fast, 0.1 - med, 1 - normal
      - "smua.measure.autozero = smua.AUTOZERO_OFF" # disables automatic updates to the internal reference measurements of the instrument
      - "smua.measure.lowrangei=1e-9" # sets the lowest measurement range that is used when the instruments is autoranging

      - "smub.source.func = smub.OUTPUT_DCVOLTS" # selects the voltage source function
      - "smub.source.output = smub.OUTPUT_ON"
      - "smub.measure.nplc = 1" # sets the integration time. 0.01 - fast, 0.1 - med, 1 - normal
      - "smub.measure.autozero = smub.AUTOZERO_OFF" # disables automatic updates to the internal reference measurements of the instrument
      - "smub.measure.lowrangei=1e-9" # sets the lowest measurement range that is used when the instruments is autoranging

      - "vlist = {-10,-6,0,1}" # sets the voltage list
      - "points = 4" # counts the point

      # Set the sweep timer
      - "trigger.timer[1].reset()"
      - "trigger.timer[1].delay = 200e-3"
      - "trigger.timer[1].stimulus = smua.trigger.SOURCE_COMPLETE_EVENT_ID" # smu A completes a source action

      # SMU A Buffer
      - "smua.nvbuffer1.clear()" # clear the buffer
      - "smua.nvbuffer1.appendmode = 1" # saves measurement to buffer
      - "smua.nvbuffer1.collectsourcevalues = 1 " # source values are stored with readings in the buffer

      - "smua.trigger.source.listv(vlist)" # sweeps  smuA through vlist
      - "smua.trigger.source.action = smua.ENABLE" # enables the source action
      - "smua.trigger.endpulse.action = smua.SOURCE_HOLD"
      - "smua.trigger.measure.i(smua.nvbuffer1)" # stores current readings during the sweep in buffer
      - "smua.trigger.measure.action = smua.ENABLE" # makes measurement during the sweep
      - "smua.trigger.measure.stimulus = trigger.timer[1].EVENT_ID" # identifies events generated by the timer
      - "smua.trigger.count = points" # number of points to output

       # SMU B Buffer
      - "smub.nvbuffer2.clear()" # clear the buffer
      - "smub.nvbuffer2.appendmode = 1" # saves measurement to buffer

      - "smub.trigger.source.listv({0,0,0,0})" # sweeps  smub through vlist
      - "smub.trigger.source.action = smub.ENABLE" # enables the source action
      - "smub.trigger.endpulse.action = smub.SOURCE_HOLD"
      - "smub.trigger.measure.i(smub.nvbuffer2)" # stores current readings during the sweep in buffer
      - "smub.trigger.measure.action = smub.ENABLE" # makes measurement during the sweep
      - "smub.trigger.measure.stimulus = trigger.timer[1].EVENT_ID" # identifies events generated by the timer
      - "smub.trigger.count = points" # number of points to output
    program:
      validation:
        anode_current[-1]:
          min:
            abs: true
            value: !!float 5e-3
            message: Current leakage is too low. Check if there is a good contact.
      measurements_kwargs:
        int_time: LONG
