# IV Matrix measurements
# SMU B - anode
# SMU A - common cathode

instruments:
  temperature:
    resource: "PT100MK1-1DCBA1.temperature"
    name: "Temperature sensor"
    kind: "temperature"
  main:
    resource: "GPIB0::26::INSTR"
    name: "Keithley SMU 2636 (Innopoli U2)"
    kind: "pyvisa"
#    invert_voltage: true # NO, the instrument is connected such that the voltage is not inverted
    kwargs:
      timeout: 200000 # 200s
  scanner:
    resource: 'GPIB0::15::INSTR'
    name: 'Scanner 705'
    kind: 'pyvisa'


matrix: 9

measure:
  # turn on the current
  - command: "smua.source.output = smua.OUTPUT_ON"
    type: "write"
  - command: "smub.source.output = smub.OUTPUT_ON"
    type: "write"

  # clear buffers
  - command: "smua.nvbuffer1.clear()"
    type: "write"
  - command: "smub.nvbuffer2.clear()"
    type: "write"

  # measure
  - command: "smub.trigger.initiate()"
    type: "write"
  - command: "smua.trigger.initiate()"
    type: "write"
  - command: "waitcomplete()"
    type: "write"

  # turn off the current
  - command: "smua.source.output = smua.OUTPUT_OFF"
    type: "write"
  - command: "smub.source.output = smub.OUTPUT_OFF"
    type: "write"

  # read buffers
  - command: "printbuffer(1, smua.nvbuffer1.n, smua.nvbuffer1.readings)"
    type: "query_csv_values"
    name: common_cathode_current
  - command: "printbuffer(1, smua.nvbuffer1.n, smua.nvbuffer1.sourcevalues)"
    type: "query_csv_values"
    name: voltage_input
  - command: "printbuffer(1, smub.nvbuffer2.n, smub.nvbuffer2.readings)"
    type: "query_csv_values"
    name: anode_current

chips:
  - voltage_input: voltage_input
    anode_current: anode_current
    cathode_current: common_cathode_current


setups:
  - name: 0.01v
    instrument:
      - "reset()"
      - "vlist =  {-0.01, -0.008, -0.006, -0.004, -0.002, 0, 0.002, 0.004, 0.006, 0.008, 0.01}"
      - "points = table.getn(vlist)"

      # Trigger
      - "trigger.timer[1].reset()"
      - "trigger.timer[1].delay = 200e-3"
      - "trigger.timer[1].stimulus = smua.trigger.SOURCE_COMPLETE_EVENT_ID" # smu A completes a source action

      # SMU A
      - "smua.source.func = smua.OUTPUT_DCVOLTS"
      - "smua.source.autorangev = smua.AUTORANGE_ON"
      - "smua.source.limiti = 100e-3" # comlience limit

      - "smua.trigger.source.listv(vlist)" # sweeps through vlist
      - "smua.trigger.source.action = smua.ENABLE" # enables the source action
      - "smua.trigger.endpulse.action = smua.SOURCE_HOLD"
      - "smua.trigger.measure.i(smua.nvbuffer1)" # stores current readings during the sweep in buffer
      - "smua.trigger.measure.action = smua.ENABLE" # makes measurement during the sweep
      - "smua.trigger.measure.stimulus = trigger.timer[1].EVENT_ID" # identifies events generated by the timer
      - "smua.trigger.count = points" # number of points to output

      - "smua.nvbuffer1.clear()"
      - "smua.nvbuffer1.appendmode = 1" # saves measurement to buffer
      - "smua.nvbuffer1.collectsourcevalues = 1 " # source values are stored with readings in the buffer

      - "smua.measure.nplc = 1" # integration time. 0.01 - fast, 0.1 - med, 1 - normal
      - "smua.measure.autozero = smua.AUTOZERO_ONCE" # AUTO is not allowed to combine with trigger
      - "smua.measure.lowrangei=1e-9" # sets the lowest measurement range that is used when the instruments is autoranging
      - 'smua.measure.delay = 3' # increase the delay to allow the current to stabilize
      # - "smua.measure.delayfactor = 4"

       # SMU B
      - "smub.source.func = smub.OUTPUT_DCVOLTS" # selects the voltage source function
      - "smub.source.levelv = 0"
      - "smub.source.limiti = 100e-3"

      - "smub.trigger.measure.i(smub.nvbuffer2)" # stores current readings during the sweep in buffer
      - "smub.trigger.measure.action = smub.ENABLE" # makes measurement during the sweep
      - "smub.trigger.measure.stimulus = trigger.timer[1].EVENT_ID" # identifies events generated by the timer
      - "smub.trigger.count = points" # number of points to output

      - "smub.nvbuffer2.clear()"
      - "smub.nvbuffer2.appendmode = 1"

      - "smub.measure.nplc = 1" # integration time. 0.01 - fast, 0.1 - med, 1 - normal
      - "smub.measure.autozero = smub.AUTOZERO_ONCE" # AUTO is not allowed to combine with trigger
      - "smub.measure.lowrangei=1e-9" # sets the lowest measurement range that is used when the instruments is autoranging
      - 'smub.measure.delay = 3' # increase the delay to 5s to allow the current to stabilize
      # - "smub.measure.delayfactor = 4"

    program:
      # minimum: true
      condition_kwargs:
        int_time: LONG # depends on smua.measure.nplc value. 0.01 - fast (SHORT), 0.1 - med (MED), 1 - normal (LONG)

  - name: 10v
    instrument:
      - "reset()"
      - "vlist = {10,9,8,7,6,5,4,3,2,1,0,-1,-2}" # sets the voltage list
      - "points = table.getn(vlist)"

      # Trigger
      - "trigger.timer[1].reset()"
      - "trigger.timer[1].delay = 200e-3"
      - "trigger.timer[1].stimulus = smua.trigger.SOURCE_COMPLETE_EVENT_ID" # smu A completes a source action

      # SMU A
      - "smua.source.func = smua.OUTPUT_DCVOLTS"
      - "smua.source.autorangev = smua.AUTORANGE_ON"
      - "smua.source.limiti = 100e-3" # comlience limit

      - "smua.trigger.source.listv(vlist)" # sweeps  smuA through vlist
      - "smua.trigger.source.action = smua.ENABLE" # enables the source action
      - "smua.trigger.endpulse.action = smua.SOURCE_HOLD"
      - "smua.trigger.measure.i(smua.nvbuffer1)" # stores current readings during the sweep in buffer
      - "smua.trigger.measure.action = smua.ENABLE" # makes measurement during the sweep
      - "smua.trigger.measure.stimulus = trigger.timer[1].EVENT_ID" # identifies events generated by the timer
      - "smua.trigger.count = points" # number of points to output

      - "smua.nvbuffer1.clear()"
      - "smua.nvbuffer1.appendmode = 1" # saves measurement to buffer
      - "smua.nvbuffer1.collectsourcevalues = 1 " # source values are stored with readings in the buffer

      - "smua.measure.nplc = 1" # sets the integration time. 0.01 - fast, 0.1 - med, 1 - normal
      - "smua.measure.autozero = smua.AUTOZERO_ONCE" # AUTO is not allowed to combine with trigger
      - "smua.measure.lowrangei=1e-9" # sets the lowest measurement range that is used when the instruments is autoranging
      - 'smua.measure.delay = 2' # increase the delay to 5s to allow the current to stabilize

        # SMU B
      - "smub.source.func = smub.OUTPUT_DCVOLTS" # selects the voltage source function
      - "smub.source.levelv = 0"
      - "smub.source.limiti = 100e-3"

      - "smub.trigger.measure.i(smub.nvbuffer2)" # stores current readings during the sweep in buffer
      - "smub.trigger.measure.action = smub.ENABLE" # makes measurement during the sweep
      - "smub.trigger.measure.stimulus = trigger.timer[1].EVENT_ID" # identifies events generated by the timer
      - "smub.trigger.count = points" # number of points to output

      - "smub.nvbuffer2.clear()"
      - "smub.nvbuffer2.appendmode = 1"

      - "smub.measure.nplc = 1" # sets the integration time. 0.01 - fast, 0.1 - med, 1 - normal
      - "smub.measure.autozero = smub.AUTOZERO_ONCE" # AUTO is not allowed to combine with trigger
      - "smub.measure.lowrangei=1e-9" # sets the lowest measurement range that is used when the instruments is autoranging
      - 'smub.measure.delay = 2' # increase the delay to 5s to allow the current to stabilize

    program:
      # minimum: true
      validation:
        anode_current[-1]:
          min:
            abs: true
            value: !!float 5e-3
            message: Current leakage is too low. Check if there is a good contact.
      condition_kwargs:
        int_time: LONG
